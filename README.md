# rec_system
Recommendation system for Movielens 100k dataset

In the age of digital media and streaming platforms, movie recommendation systems have become indispensable tools for enhancing user experience and engagement. With vast libraries of films and television content available at users’ fingertips, these systems help viewers navigate through overwhelming choices by surfacing relevant and personalized suggestions. Whether it's Netflix recommending a drama based on your previous watches or IMDb suggesting trending thrillers, recommendation engines are central to content discovery, user retention, and platform success.

Movie recommendation systems rely on various algorithmic strategies to predict what a user might enjoy watching next. Among the most common techniques are User-Based Collaborative Filtering (UBCF) and Item-Based Collaborative Filtering (IBCF). UBCF recommends movies to a user by identifying similar users based on shared viewing or rating patterns. It assumes that users who agreed in the past will continue to agree in the future. IBCF, on the other hand, focuses on relationships between items (movies). It identifies similarities between movies based on how they were rated or interacted with across users and recommends items similar to those the user has already liked.

While collaborative filtering methods have proven effective, they often suffer from scalability and sparsity issues as the user-item matrix grows. To overcome these limitations, more advanced approaches like Graph-Based Recommendation Algorithms, including Pixie-inspired models, have gained traction. These systems represent users and items as nodes in a graph, with interactions forming edges, and leverage random walks to explore relevant connections in the network. The Pixie-inspired method enhances personalization and scalability by using multiple random walks from a user’s interaction history to discover tightly connected and contextually relevant movie suggestions.

Each of these approaches brings unique strengths. UBCF is intuitive and easy to implement but struggles with new users (cold start problem). IBCF scales better and offers item-level insights, which are more stable over time. Graph-based models, though computationally more complex, provide richer contextual recommendations by capturing complex relationships in large-scale interaction graphs. Together, these techniques form the backbone of modern recommender systems, and choosing the right approach often depends on the dataset size, diversity of content, and performance requirements.
For this project, I used the MovieLens 100K dataset, which contains 100,000 movie ratings (on a scale of 1 to 5) provided by 943 users for 1,681 different movies. Each user in the dataset has rated a minimum of 20 movies, ensuring sufficient data for collaborative filtering techniques. Additionally, the dataset includes basic demographic information for each user, such as age, gender, occupation, and ZIP code, allowing for potential user segmentation and enhanced personalization. The features selected were user_id, movie_id, rating, timestamp from the ratings dataset; title and release_date for each movie; and age, gender and occupation for each user. For preprocessing the data, the missing values were handled by dropping the corresponding rows since the number was not significant, duplicates were identified and removed, and the timestamp column was converted into datetime format. 

For implementation of recommendation system, a user_movie_matrix was created by pivoting the ratings dataset and plotting the users against the movies and filling the cells with their rating. Any movie not rated by a user was filled with 0 value. 

For user-based collaborative filtering, I used cosine similarity to measure how similar each pair of users is based on their movie ratings. The user-based collaborative filtering implementation revolves around identifying users with similar preferences to the target user and leveraging their ratings to generate recommendations. To achieve this, I defined the function recommend_movies_for_user(user_id, num=5). The function first retrieves the similarity scores for the given user_id from a precomputed user similarity matrix, sorting them in descending order and excluding the user themselves. It then gathers movie ratings from these top similar users. For each movie, the function computes the average rating across these users to estimate relevance. The movies are then sorted by their average ratings in descending order, and the top num recommendations are selected. Finally, movie IDs are mapped to their corresponding titles using the movies DataFrame, and the results are returned as a ranked Pandas DataFrame.

In item-based collaborative filtering, we compute movie-to-movie similarity using cosine similarity on user ratings. Since cosine_similarity doesn't handle missing values, we fill them with zeros. The user_movie_matrix is transposed so movies become rows, enabling similarity calculation between them. After applying cosine_similarity, the result is converted into a Pandas DataFrame with movie titles as both rows and columns for easy reference. To recommend similar movies, we define recommend_movies(movie_name, num=5). The function finds the corresponding movie_id for the given title, and if not found, returns an appropriate message. It then retrieves and sorts similarity scores from item_sim_df, excluding the movie itself. The top num results are mapped back to their titles and returned as a ranked Pandas DataFrame.

In the Pixie-inspired random walk recommendation method, we first preprocess the MovieLens dataset to construct a user-movie interaction graph. Each user is connected to the movies they’ve rated, and each movie is connected back to the users who rated it, forming a bidirectional structure ideal for graph traversal. To handle duplicate ratings, we group the dataset by ['user_id', 'movie_id', 'title'] and compute the mean rating for each movie by each user. We then normalize ratings by subtracting each user’s average rating from their individual ratings, reducing personal bias and making preferences more comparable across users.

We represent the graph using an adjacency list implemented as a dictionary. Each key corresponds to a user or movie node, and the values are sets of connected nodes. By iterating through the normalized dataset, we add movies to each user’s set of connections and users to each movie’s set. This undirected graph structure captures all relevant relationships and serves as the basis for random walk-based exploration, allowing the recommendation algorithm to identify relevant movies by simulating user navigation through similar interests in the network. Graph-based approaches are effective because they capture complex relationships and indirect connections between users and items that traditional methods might miss. By modeling interactions as a network, these approaches enable personalized and context-aware recommendations through efficient traversal and pattern discovery.

